# Design 0.2 of the module system

Changes compared to design 0.1:

  * We rely on the Cray LMOD modules for the programming environment
    and don't try to copy those to our own directory structures as
    there is not that much to gain from it given the hierarchical
    structure.
  * We avoid reading environment variables in the partition and stack
    modules and instead produce them via running a template through
    the gpp preprocessor. This is simpler than letting each module
    remember its settings.
  * We need to see if we will create PrgEnv-* equivalents in the
    LUMI/yy.mm software stacks using EasyBuild (as in CSCS) or via
    our own script, in which case we would put them elsewhere. In that
    case we could even initialise a LUMI/yy.mm software stack without
    using EasyBuild, which granted is not a good match with the
    "EasyBuild first" strategy.

## Hierarchy with software stack first, partition/architecture second, flat otherwise - Prototype module_stack_partition_MOD and module_stack_partition_EB

Here we mount the same file system with applications and modules
everywhere, but within that file system we have binaries for each
architecture in separate directories

Directory hierarchy

-   Cray modules in their own hierarchy.

-   appl

    -    modules

        -   SoftwareStack: A module file that enables the default Cray
            environment, and one for each of our LUMI software stacks.

        -   LUMI-21.02: All module files for our software stack based on
            CPE release 21.02 (the one that was available on the
            Grenoble nodes early April \'21)

            -   LUMIpartition: Contains the module files to activate the
                modules for LUMI-C, LUMI-G, LUMI-D and LUMI-L (the
                login nodes). By default, whenever a LUMI/XX.YY module
                is loaded we already load the relevant one of these
                modules for the node type that the user is on. We use
                LUMIpartition in an effort to avoid all confusion with
                SLURM partitions.

            -   LUMI-L: Modules for the LUMI/21.02 software stack for
                LUMI-L

                -   easybuild: EasyBuild modules

                -   spack: Space to put modules generated by Spack

                -   manual: Space to put module files for software
                    installed in other ways

            -   LUMI-D: Modules for the LUMI/21.02 software stack for
                LUMI-D

            -   LUMI-C: Modules for the LUMI/21.02 software stack for
                LIMI-C

            -   LUMI-G: Modules for the LUMI/21.02 software stack for
                LIMU-G

    -   software

        -   LUMI-21.02

            -   LUMI-C

                -   easybuild

                -   spack

                -   manual

            -   LUMI-G

            -   LUMI-D

            -   LUMI-L

    -   mgmt: Files that are not stored in our GitHub, but are generated
        on the fly and are only useful to those users who want to
        build upon our software stack or for those who install
        software in our stacks. 

        -   ebrepo_files

            -   LUMI-21.02

                -   LUMI_L

                -   LUMI-D

                -   LUMI-C

                -   LUMI-O

    -   github: GitHub repository with all managed files

        -   easybuild

            -   easyconfig

            -   config: Configuration of EasyBuild

            -   Structure for hooks and easyblocks to be decided.

A variant of this scheme would be instead store the software and modules
together in the EasyBuild way (and possibly in the Spack-way for spack,
etc.). The EasyBuild-generated repofiles could then also be stored with
the software and modules:

-   Cray modules in their own hierarchy.

-   appl

    -    modules

        -   SoftwareStack: A module file that enables the default Cray
            environment, and one for each of our LUMI software stacks.

        -   LUMI-21.02: All module files for our software stack based on
            CPE release 21.02 (the one that was available on the
            Grenoble nodes early April \'21)

            -   LUMIpartitions: Contains the module files to activate
                the modules for LUMI-C, LUMI-G, LUMI-D and LUMI-L (the
                login nodes). By default, whenever a LUMI/XX.YY module
                is loaded we already load the relevant one of these
                modules for the node type that the user is on.

    -   stack

        -   LUMI-21.02

            -   LUMI-C

                -   easybuild

                    -   software: LUMI-L binaries build with EasyBuild

                    -   modules: Modules for those binaries

                    -   ebrepo_files: Corresponding EasyBuild-processed
                        EasyConfig files.

                -   spack

                -   manual

                    -   software

                    -   modules

            -   LUMI-D: Organised in the same way as the LUMI-L
                subdirectory

            -   LUMI-C: Organised in the same way as the LUMI-L
                subdirectory

            -   LUMI-O: Organised in the same way as the LUMI-L
                subdirectory

    -   github: GitHub repository with all managed files

        -   easybuild

            -   easyconfig

            -   config: Configuration of EasyBuild

            -   Structure for hooks and easyblocks to be decided.

### Assumptions

-   The system sets an environment variable LUMI_PARTITION with value
    LUMI-C, LUMI-G, LUMI-D or LUMI-L depending on the node type.

### Default behaviour when loading modules

-   A user will always need to load a software stack module first.

    -   For those software stack modules that further split up according
        to partition (the LUMI-XX.YY modules), the relevant partition
        module will be loaded automatically when loading the software
        stack.

### Advantages

-   Having the software stack as the highest level in the hierarchy
    makes it easy to also make other software stacks available through
    software stack modules that can then each have their own internal
    organisation, e.g., EESSI should it mature enough during the life of
    LUMI and become suitable for LUMI and should we find a distribution
    mechanism that would integrate with LUMI.

-   \...

### Disadvantages

-   \...

## Hierarchy with the partition first, software stack second, flat otherwise - Prototype make_partition_stack_MOD and make_partition_stack_EB

Here we mount the same file system with applications and modules
everywhere, but within that file system we again have binaries for each
architecture in separate directories

Directory hierarchy

-   Cray modules in their own hierarchy.

-   appl

    -   modules

        -   LUMIpartition: Modules to adapt the module path for a
            partition.

        -   LUMI-C

            -   SoftwareStack: Software stack modules for LUMI-C

            -   LUMI-21.02: Modules for the LUMI-21.02 software stack on
                LUMI-C

                -   easybuild

                -   spack

                -   manual

        -   LUMI-G: Organised in the same way as LUMI-C

        -   LUMI-D: Organised in the same way as LUMI-C

        -   LUMI-L: Organised in the same way as LUMI-C

    -   software

        -   LUMI-C

            -   LUMI-21.02

                -   easybuild

                -   spack

                -   manual

    -   mgmt

        -   ebrepo_files

            -   LUMI-C

                -   LUMI-21.02

    -   github: GitHub repository with all managed files

        -   easybuild

            -   easyconfig

            -   config: Configuration of EasyBuild

            -   Structure for hooks and easyblocks to be decided.

A variant of this scheme would be instead store the software and modules
together in the EasyBuild way (and possibly in the Spack-way for spack,
etc.). The EasyBuild-generated repofiles could then also be stored with
the software and modules:

-   Cray modules in their own hierarchy.

-   appl

    -   modules

        -   LUMIpartition: Modules to adapt the module path for a
            partition.

        -   LUMI-C

            -   SoftwareStack: Software stack modules for LUMI-C

        -   LUMI-G: See LUMI-C

        -   LUMI-D: See LUMI-C

        -   LUMI-L: See LUMI-C

    -   stack

        -   LUMI-C

            -   LUMI-21.02

                -   easybuild

                    -   software

                    -   modules

                    -   EBrepo_files

                -   spack

                -   manual

                    -   software

                    -   modules

    -   github: GitHub repository with all managed files

        -   easybuild

            -   easyconfig

            -   config: Configuration of EasyBuild

            -   Structure for hooks and easyblocks to be decided.

### Assumptions

-   The system sets an environment variable LUMI_PARTITION with value
    LUMI-C, LUMI-G, LUMI-D or LUMI-L depending on the node type.

### Default behaviour when loading modules

-   The system will have the right partition module loaded for the
    partition type. These are sticky modules but can be swapped at the
    user\'s own risk.

### Advantages

-   \...

### Disadvantages

-   This setup is more confusing if there are also software stacks that
    do not depend on the architecture (e.g., offering the native Cray
    environment) or that have other means to deal with the architecture
    (e.g., EESSI should we ever offer that, though we may as well not
    use the EESSI way to select the optimal architecture).

### Remarks

-   Wether we will simply call the modules to change to a partition
    LUMI-X or work with versions of the LUMIpartition module
    (partition/LUMI-X) depends also on whether we want to make those
    modules sticky (which makes a lot of sense when they are the first
    level in the hierarchy) and if we allow to simply load a different
    sticky module of the LUMIpartition family or configure LMOD such
    that sticky modules can only be swapped with another version of the
    module (which would require using versions of the partition module
    rather than simply use different modules in a single LUMIpartition
    family).

